<svelte:options tag="opt-kit" />

<script>
  import { onDestroy, onMount, tick } from "svelte";
  import { fade, fly } from "svelte/transition";
  import { backOut } from "svelte/easing";

  let password, confirmPassword;
  let confirmEl, showConfirm, acceptConfirm, denyConfirm;
  const confirm = async (msg, pw) =>
    new Promise((resolve, reject) => {
      password = pw;
      confirmPassword = "";
      document.body.style.overflow = "hidden";
      showConfirm = msg;
      setTimeout(() => confirmEl.focus(), 100);
      acceptConfirm = () => {
        showConfirm = false;
        document.body.style.overflow = null;
        resolve(true);
      };
      denyConfirm = () => {
        showConfirm = false;
        document.body.style.overflow = null;
        resolve(false);
      };
    });

  let alerts = [];
  let callback;
  let alertId = 0;
  const alert = (
    msg = "",
    type = "notification",
    autoHide = true,
    onClose = false,
    retainMs = 3500
  ) => {
    let _id = ++alertId;
    alerts = [
      ...alerts,
      {
        _id,
        msg,
        type,
      },
    ];
    if (autoHide) {
      setTimeout(() => {
        removeAlert(_id);
      }, retainMs);
    }
    if (onClose) callback = onClose;
  };

  const removeAlert = (_id) => {
    alerts = alerts.filter((a, i) => a._id !== _id);
    if (callback) callback();
  };

  let promptEl,
    promptErr,
    promptOptions,
    promptInput,
    promptQuestion,
    promptAnswer,
    showPrompt,
    resolvePrompt;
  let prompt = (question, options = {}) =>
    new Promise(async (resolve, reject) => {
      document.body.style.overflow = "hidden";
      promptErr = false;
      showPrompt = true;
      promptAnswer = "";
      promptQuestion = question;
      promptOptions = options;
      await tick();
      promptInput.focus();
      resolvePrompt = async (to) => {
        showPrompt = false;
        resolve(to);
        await tick();
        promptAnswer = null;
        document.body.style.overflow = null;
      };
    });

  const flyIn = {
    delay: 0,
    duration: 200,
    x: 0,
    y: 50,
    opacity: 0.1,
    easing: backOut,
  };
  const fadeOut = { duration: 100, opacity: 0 };

  function handleKeydown(event) {
    let key = event.key;
    let keyCode = event.keyCode;
    if (showConfirm) {
      if (key === "Enter") {
        acceptConfirm();
      }
      if (key === "Escape") {
        denyConfirm();
      }
    }
    if (showPrompt) {
      if (key === "Enter") {
        resolvePrompt(promptAnswer);
      }
      if (key === "Escape") {
        resolvePrompt(null);
      }
    }
  }

  let menuEl;
  let menuVisible = false;
  let menuItems = [];
  let innerWidth;

  function menu(e, items) {
    console.log("menu()", { e, items });
    if (menuVisible || !e) {
      toggleMenu("hide");
      window.removeEventListener("click", windowToggle);
      setUp = false;
    } else {
      window.addEventListener("click", windowToggle);
      e && e.preventDefault && e.preventDefault();
      menuItems = items;
      open(e);
    }
  }

  function open(e) {
    console.log("open()", { e });
    if (!menuItems || menuItems.length === 0) {
      console.error("No menu() Items Found");
      return true;
    }
    const x = e.clientX;
    const y = e.clientY;
    const origin = { left: x, top: y };
    setPosition(origin);
    return false;
  }

  const setPosition = ({ top, left }) => {
    if (!menuEl) return;
    let outOfBounds = left + 160 > innerWidth;
    menuEl.style.left = `${!outOfBounds ? left : left - 160}px`;
    menuEl.style.top = `${top}px`;
    toggleMenu("show");
  };

  const toggleMenu = async (command) => {
    console.log("toggleMenu()", { command });
    if (!menuEl || menuItems.length === 0) {
      return;
    }
    menuEl.style.display = command === "show" ? "block" : "none";
    menuVisible = !menuVisible;
  };
  let setUp;
  const windowToggle = () => {
    if (!setUp) {
      setUp = true;
      return;
    }
    console.log("windowToggle()", { menuVisible, menuItems });
    menu();
  };

  onMount(() => {
    window.alert = alert;
    window.prompt = prompt;
    window.confirm = confirm;
    window.menu = menu;
  });
  onDestroy(() => {});
</script>

<svelte:window on:keydown={handleKeydown} bind:innerWidth />

{#if alerts && alerts.length > 0}
  <div class="wrapper">
    {#each alerts as toast (toast._id)}
      <div
        in:fly={flyIn}
        out:fade={fadeOut}
        on:click={(_) => removeAlert(toast._id)}
        class="modal"
      >
        <div class="p-2">{toast.msg}</div>
        <button
          type="button"
          class="close"
          on:click={(_) => removeAlert(toast._id)}
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <line data-v-4c034fe6="" x1="18" y1="6" x2="6" y2="18" />
            <line data-v-4c034fe6="" x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      </div>
    {/each}
  </div>
{/if}

{#if showConfirm}
  <div class="backdrop" on:click={denyConfirm}>
    <div
      bind:this={confirmEl}
      class="modal"
      in:fly={flyIn}
      out:fade={fadeOut}
      on:click={(e) => (e.cancelBubble = true)}
    >
      <button
        on:click={denyConfirm}
        type="button"
        class="close focus:ring focus:outline-none"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="icon-svg feather feather-x"
        >
          <line data-v-4c034fe6="" x1="18" y1="6" x2="6" y2="18" />
          <line data-v-4c034fe6="" x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </button>

      <div class="my-10">
        {showConfirm}
        {#if password}
          <label>
            <div class="">
              Type "{password}" to confirm:
            </div>
            <input
              placeholder={password}
              class="input"
              bind:value={confirmPassword}
            />
          </label>
        {/if}
      </div>

      <nav class="">
        <button class="btn cancel" on:click={denyConfirm}> Cancel </button>

        <button
          class="btn ok"
          disabled={password && confirmPassword !== password}
          on:click={acceptConfirm}
        >
          Ok
        </button>
      </nav>
    </div>
  </div>
{/if}

{#if showPrompt}
  <div class="backdrop" on:click={(e) => (showPrompt = null)}>
    <div
      on:click={(e) => (e.cancelBubble = true)}
      bind:this={promptEl}
      class="modal"
      in:fly={flyIn}
      out:fade={fadeOut}
    >
      <nav class="">
        {#if promptOptions.headline}
          <h1>{promptOptions.headline}</h1>
        {/if}
        <button
          on:click={(_) => resolvePrompt(null)}
          type="button"
          class="close focus:ring focus:outline-none"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="icon-svg feather feather-x"
          >
            <line data-v-4c034fe6="" x1="18" y1="6" x2="6" y2="18" />
            <line data-v-4c034fe6="" x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      </nav>
      <div class="">
        <div class="my-10">
          <div class="p-2">
            {promptQuestion || ""}
          </div>
          {#if promptOptions.select}
            <select
              class="input"
              bind:this={promptInput}
              placeholder={promptOptions.placeholder || ""}
              bind:value={promptAnswer}
            >
              {#each promptOptions.select as {value="", label=""}}
                <option {value}>{label}</option>
              {/each}
            </select>
          {:else}
            {#if promptOptions.label}
              <label for="prompt">{promptOptions.label}</label>
            {/if}
            <input
              id="prompt"
              class="input"
              type="text"
              bind:this={promptInput}
              placeholder={promptOptions.placeholder || ""}
              required
              showError={promptErr && !promptAnswer}
              bind:value={promptAnswer}
            />
          {/if}
        </div>

        <div class="">
          <button class="btn cancel" on:click={(_) => resolvePrompt(null)}>
            {promptOptions.cancel || "Cancel"}
          </button>

          <button
            tabindex="0"
            class="btn ok"
            on:click={(_) => {
              if (!promptAnswer) {
                alert(promptOptions.errorMessage || "Required", "error");
                promptErr = true;
                return;
              }
              resolvePrompt(promptAnswer);
            }}
          >
            {promptOptions.ok || "Ok"}
          </button>
        </div>
      </div>
    </div>
  </div>
{/if}

<div bind:this={menuEl} class="menu">
  {#if menuItems.length > 0}
    <div>
      {#each menuItems as item, i}
        <button
          class="btn"
          on:click={(e) => {
            item.onClick && item.onClick();
            menu();
          }}
        >
          {item.label}
        </button>
      {/each}
    </div>
  {/if}
</div>

<style>
  * {
    --tw-shadow: 0 0 #0000;
  }
  .wrapper {
    position: fixed;
    width: 100%;
    left: 0;
    right: 0;
    top: 0;
    pointer-events: none;
    z-index: 2147483647;
    padding: 1rem;
  }
  .modal {
    background-color: white;
    position: relative;
    pointer-events: auto;
    padding: 2rem 4rem;
    border: 1px solid rgba(0, 0, 0, 0.06);
    border-radius: 0.2rem;
    box-shadow: 0 25px 50px -12px rgb(0 0 0 / 25%);
    background: #fff;
    margin: 2rem auto;
    width: 100%;
    max-width: 20rem;
    word-break: break-word;
    overflow: hidden;
    text-align: center;
  }
  .close {
    height: 35px;
    width: 35px;
    position: absolute;
    right: 0;
    top: 0;
    margin: 1rem;
  }
  .backdrop {
    background: rgba(26, 32, 44, 0.35);
    padding: 1rem;
    position: fixed;
    width: 100%;
    height: 100%;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
  }
  .input {
    width: 100%;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    padding: 0.75rem;
    flex-grow: 1;
    background-color: rgba(229, 231, 235, 1);
    border-width: 1px;
    border-radius: 0.25rem;
    font-family: inherit;
    font-size: 100%;
    line-height: 1.15;
    margin: 0;
  }
  .btn {
    font-weight: 600;
    border-width: 1px;
    padding-left: 1rem;
    padding-right: 1rem;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
    margin-right: 1rem;
    font-weight: 600;
    border-radius: 0.25rem;
    line-height: inherit;
    cursor: pointer;
    background-image: none;
    -webkit-appearance: button;
    text-transform: none;
    font-family: inherit;
    font-size: 100%;
    line-height: 1.15;
    margin: 0;
  }
  .cancel {
    background-color: rgba(243, 244, 246, 1);
  }
  .ok {
    background-color: rgba(59, 130, 246, 1);
    color: rgba(255, 255, 255, 1);
  }
  .menu {
    position: fixed;
    z-index: 2147483647;
    width: 100%;
    max-width: 160px;
    background: white;
    box-shadow: 0 25px 50px -12px rgb(0 0 0 / 25%);
  }
  .menu .btn {
    width: 100%;
    border-radius: 0;
    /* margin-top: -1px; */
  }
  .menu .btn:nth-child(1) {
    border-top-left-radius: 0.25rem;
    border-top-right-radius: 0.25rem;
    border-bottom: 0;
    margin-top: 0;
  }
  .menu .btn:last-child {
    border-top: 0;
    border-bottom-left-radius: 0.25rem;
    border-bottom-right-radius: 0.25rem;
    margin-top: 0;
  }
  /* 
  utilities
  */
  .my-10 {
    margin-top: 2.5rem;
    margin-bottom: 2.5rem;
  }
  .p-2 {
    padding: 0.5rem;
  }
</style>
